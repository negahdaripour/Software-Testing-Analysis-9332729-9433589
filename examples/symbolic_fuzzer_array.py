"""Symbolic Fuzzer for Lists

Before Use make sure to install the fuzzingbook package.

An Advanced Fuzzer is initialized. Data is Generated and stored. The test function is called
using the generated data, and the resutls are printed. 
ArcCoverage is used as a tracer that uses data generated by the fuzzer to determine how much
of the paths are reachable. 
Control flow graph is generated and viewed.
To generate and view the graph, change the code on line 41 and insert unique filename and
directory.
Imported Function 'paths_and_constraints' is called to print the paths and their constraints.

The feature SPECIFIC to this file is how the data generated by the fuzzer is stored.


the 'fuzz()' function in ModifiedSymbolicFuzzer is changed to generate a list of 'None' 
with size 10. it is then ready generate data for any index of the list from 0 to 9. 
the generated data is then outputed as a list, the only elements of which that are 
real data are the ones that where used in the function.
"""

from fuzzingbook.ConcolicFuzzer import ArcCoverage
from utils.ModifiedSymbolicFuzzer import *
from fuzzingbook.ControlFlow import PyCFG, CFGNode, to_graph, gen_cfg
import inspect
from graphviz import Source, Graph

from utils.paths_and_constraints import paths_and_constraints
from input_functions.array_test import test_function


def symbolic_fuzzer_array():
    """Prints fuzzing data and genertes Control Flow Graph

    Args: 
        None
    """
    
    sym_fuzzer = AdvancedSymbolicFuzzer(
        test_function,
        max_tries = 10,
        max_iter = 10,
        max_depth =10
    )

    data = []

    for i in range(10):
        r = sym_fuzzer.fuzz()
        
        if type(r['b']) == list:
            b = []
            for j in r['b']:
                if j != None:
                    b.append(j.as_long())
            data.append((r['a'].as_long(),b))        
            v = test_function(*data[-1])
            print(r, " Result", repr(v))
        

    with ArcCoverage() as cov:
        for a, b in data:
            test_function(a, b)

    graph = Source(to_graph(gen_cfg(inspect.getsource(test_function)), arcs= cov.arcs()))
    #graph.view(filename="tf_10.gv", directory="E:\dir\graphs")

    paths_and_constraints(test_function)



