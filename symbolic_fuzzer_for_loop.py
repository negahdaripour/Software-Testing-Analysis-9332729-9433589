"""Symbolic Fuzzer for fFor Loops

Before Use make sure to install the fuzzingbook package.

An Advanced Fuzzer is initialized. Data is Generated and stored. The test function is called
using the generated data, and the resutls are printed. 
ArcCoverage is used as a tracer that uses data generated by the fuzzer to determine how much
of the paths are reachable. 
Control flow graph is generated and viewed.
To generate and view the graph, change the code on line 41 and insert unique filename and
directory.
Imported Function 'paths_and_constraints' is called to print the paths and their constraints.

This program first calls the imported function, 'main' and turns the for loop into a while
loop, we then import the generated function and continue fuzzing. 
"""

from fuzzingbook.ConcolicFuzzer import ArcCoverage
from utils.ModifiedSymbolicFuzzer import *
from fuzzingbook.ControlFlow import PyCFG, CFGNode, to_graph, gen_cfg
import inspect
from graphviz import Source, Graph

if __name__ == "__main__":
    from utils.paths_and_constraints import paths_and_constraints
    from utils.fuzzer_utils import main

    main()

    from examples.converted_functions import for_test_function

    sym_fuzzer = AdvancedSymbolicFuzzer(
        for_test_function,
        max_tries = 10,
        max_iter = 10,
        max_depth =10
    )

    data = []

    for i in range(10):
        r = sym_fuzzer.fuzz()
        data.append((r['a'].as_long(), r['b'].as_long()))
        v = for_test_function(*data[-1])
        print(r, "Result", repr(v))

    print("Num of Data:", len(data))

    with ArcCoverage() as cov:
        for a, b in data:
            for_test_function(a, b)

    graph = Source(to_graph(gen_cfg(inspect.getsource(for_test_function)), arcs= cov.arcs()))
    graph.view(filename="tf_12.gv", directory="E:\dir\graphs")

    paths_and_constraints(for_test_function)



